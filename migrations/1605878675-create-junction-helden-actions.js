const classActions = [
  {
    class_name: 'Warrior',
    action_name: 'body onslaught',
  },
  {
    class_name: 'Mage',
    action_name: 'arcane scourge',
  },
  {
    class_name: 'Gunner',
    action_name: 'accurate shot',
  },
  {
    class_name: 'Healer',
    action_name: 'supernatural healing',
  },
];

exports.up = async (sql) => {
  await sql`
	CREATE TABLE IF NOT EXISTS class_actions_set (
		action_type_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
		combat_action_id integer REFERENCES combat_action (combat_action_id) ON DELETE CASCADE,
		class_id integer REFERENCES helden_class (class_id) ON DELETE CASCADE
	);`;

  const classActionsWithBasic = [
    ...classActions,
    ...classActions.map((action) => {
      const actionCopy = { ...action };
      actionCopy.action_name = 'basic attack';
      return { ...actionCopy };
    }),
  ];

  const promises = classActionsWithBasic.map(async (obj) => {
    const [heldenClass] = await sql`
		SELECT action.combat_action_id, class.class_id  FROM
			helden_class as class,
			combat_action as action
		WHERE
			class.class_name = ${obj.class_name}
		AND
			action.action_name = ${obj.action_name}
		;`;
    return heldenClass;
  });

  const junctionObj = await Promise.all(promises);

  const junctionInfo = await sql`
	INSERT INTO class_actions_set ${sql(
    junctionObj,
    'combat_action_id',
    'class_id',
  )} RETURNING *
	`;
};

exports.down = async (sql) => {
  await sql`DROP TABLE IF EXISTS class_actions_set;`;
};
